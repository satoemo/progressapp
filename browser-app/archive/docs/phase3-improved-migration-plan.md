# Phase 3 改良版移行計画

## 実施日時
2025-08-22

## 今回の教訓

### 失敗の原因
1. **変更が大きすぎた** - 一度に全体を変更しようとした
2. **ビジネスロジックの喪失** - Event Sourcingと一緒に重要な処理も削除
3. **テスト不足** - 各ステップでの動作確認が不十分
4. **互換性の軽視** - 既存コードとの互換性を十分に考慮しなかった

### 学んだこと
- **小さく、確実に** - 1つずつ機能を移行
- **ビジネスロジックを保持** - パターンを変えてもロジックは維持
- **常にテスト** - 各変更後に必ず動作確認
- **後方互換性** - 既存コードが動作し続けることを保証

## 新しい移行戦略

### 基本方針
- **1機能1PR** - 1つの機能を1つのフェーズで完全に移行
- **並行稼働** - 新旧システムを共存させて段階的に切り替え
- **テストファースト** - 変更前にテストケースを作成
- **ロールバック可能** - 各フェーズで問題があれば即座に戻せる

## 詳細フェーズ計画

### Phase 3.4: 準備フェーズ（1日）
**目的**: 移行の土台作り

#### 3.4.1 テスト環境の整備
- [ ] 統合テストの作成
- [ ] パフォーマンステストの作成
- [ ] 動作確認チェックリストの作成

#### 3.4.2 並行稼働の準備
- [ ] ApplicationServiceとAppServiceの共存設定
- [ ] フィーチャーフラグの実装
- [ ] 切り替えメカニズムの構築

### Phase 3.5: データ層の移行（3日）
**目的**: Event Storeを段階的にシンプルなStoreに移行

#### 3.5.1 CutStoreの実装（ApplicationService互換）
- [ ] CutStoreをApplicationServiceのインターフェースに合わせて実装
- [ ] EventSourcedCutRepositoryのラッパーとして動作
- [ ] テスト: カット作成、更新、削除

#### 3.5.2 MemoStoreの実装（ApplicationService互換）
- [ ] MemoStoreをApplicationServiceのインターフェースに合わせて実装
- [ ] EventSourcedMemoRepositoryのラッパーとして動作
- [ ] テスト: メモ作成、更新、削除

#### 3.5.3 データ移行の検証
- [ ] 既存データの読み込みテスト
- [ ] 新規データの作成テスト
- [ ] パフォーマンステスト

### Phase 3.6: コマンド処理の移行（5日）
**目的**: CommandHandlerのロジックを保持しながら簡素化

#### 3.6.1 CreateCutCommandの移行
- [ ] CreateCutCommandHandlerのロジックを抽出
- [ ] AppServiceに統合（ApplicationService経由）
- [ ] テスト: ダミーデータ生成、初期データ設定

#### 3.6.2 UpdateProgressCommandの移行
- [ ] UpdateProgressCommandHandlerのロジックを抽出
- [ ] バリデーションとビジネスルールを保持
- [ ] テスト: 進捗更新、状態遷移

#### 3.6.3 UpdateBasicInfoCommandの移行
- [ ] UpdateBasicInfoCommandHandlerのロジックを抽出
- [ ] フィールドごとの更新ルールを保持
- [ ] テスト: 基本情報更新

#### 3.6.4 UpdateCostCommandの移行
- [ ] UpdateCostCommandHandlerのロジックを抽出
- [ ] 金額計算ロジックを保持
- [ ] テスト: コスト更新、合計計算

#### 3.6.5 その他のコマンドの移行
- [ ] DeleteCutCommand
- [ ] UpdateKenyoCommand
- [ ] UpdateCellMemoCommand

### Phase 3.7: クエリ処理の移行（2日）
**目的**: QueryHandlerを簡素化

#### 3.7.1 GetAllCutsQueryの移行
- [ ] ReadModelStoreの代わりにCutStoreを使用
- [ ] フィルタリングロジックを保持
- [ ] テスト: 全件取得、フィルタリング

#### 3.7.2 その他のクエリの移行
- [ ] GetCutByIdQuery
- [ ] GetCellMemoQuery
- [ ] テスト: 個別取得

### Phase 3.8: UI層の調整（3日）
**目的**: UI層を新しいサービス層に接続

#### 3.8.1 ProgressTableの移行
- [ ] ApplicationServiceからAppServiceへの切り替え
- [ ] 合計計算機能の確認
- [ ] テスト: 表示、編集、フィルタ

#### 3.8.2 その他のViewの移行
- [ ] StaffView
- [ ] SimulationView
- [ ] ScheduleView
- [ ] テスト: 各ビューの動作確認

### Phase 3.9: Event Sourcing削除（2日）
**目的**: 不要になったEvent Sourcing関連コードを削除

#### 3.9.1 EventStoreの削除
- [ ] HybridEventStoreの削除
- [ ] InMemoryEventStoreの削除
- [ ] LocalStorageEventStoreの削除

#### 3.9.2 Event/Aggregateの削除
- [ ] CutAggregateの削除
- [ ] DomainEventの削除
- [ ] EventSourcedAggregateRootの削除

### Phase 3.10: 最終調整（2日）
**目的**: パフォーマンス最適化とクリーンアップ

#### 3.10.1 パフォーマンス最適化
- [ ] 不要な処理の削除
- [ ] キャッシュの実装
- [ ] バッチ処理の最適化

#### 3.10.2 コードクリーンアップ
- [ ] 不要なファイルの削除
- [ ] リファクタリング
- [ ] ドキュメント更新

## チェックポイント

各フェーズ完了時に以下を確認：

### 機能チェック
- [ ] ダミーデータ生成が10秒以内
- [ ] 全フィールドが正しく保存される
- [ ] ヘッダー合計が表示される
- [ ] フィルタが正常に動作する
- [ ] ソートが正常に動作する

### パフォーマンスチェック
- [ ] 初期表示: 1秒以内
- [ ] データ更新: 100ms以内
- [ ] フィルタリング: 500ms以内

### エラーチェック
- [ ] コンソールエラーなし
- [ ] TypeScriptエラーなし
- [ ] ビルドエラーなし

## リスク管理

### 各フェーズのリスク
- **低リスク**: 3.4, 3.7, 3.10
- **中リスク**: 3.5, 3.8, 3.9
- **高リスク**: 3.6（最も重要なビジネスロジック）

### ロールバック戦略
1. 各フェーズ開始前にGitタグを作成
2. 問題発生時は即座に前のタグに戻す
3. 問題を分析して計画を修正

## タイムライン

- **Week 1**: Phase 3.4 - 3.5
- **Week 2**: Phase 3.6
- **Week 3**: Phase 3.7 - 3.8
- **Week 4**: Phase 3.9 - 3.10

合計: 約4週間（慎重に進める）

## 成功の定義

1. **機能的成功**
   - 全機能が正常に動作
   - データの整合性が保たれる
   - UIが期待通りに表示される

2. **技術的成功**
   - コードがシンプルになる
   - パフォーマンスが向上する
   - メンテナンスが容易になる

3. **プロセス的成功**
   - 計画通りに進行
   - 大きな手戻りがない
   - チーム（ユーザー）の満足度が高い