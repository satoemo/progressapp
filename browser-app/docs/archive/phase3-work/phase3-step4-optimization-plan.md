# Phase 3 Step 4: パフォーマンス最適化計画

## 目標
- StaffView.ts: 67ループ → 20以下
- ProgressTable.ts: 48ループ → 15以下

## StaffView.ts 最適化戦略

### 1. データ集計の統合（削減見込み: -30ループ）
**現在の問題**：
```typescript
// 3箇所で同じパターンの3重ネストループ
staffInfoMap.forEach(staffInfo => {
  roleConfig.progressFields.forEach(field => {
    staffInfo.cuts.forEach(cut => {
      // 処理
    });
  });
});
```

**解決策**：
- 単一パスでデータを集計するメソッドを作成
- Map/Reduceパターンで並列処理可能な構造に変更
- キャッシュを活用して重複計算を削減

### 2. DOM操作の最適化（削減見込み: -10ループ）
**現在の問題**：
- 個別の要素作成でforEachを使用

**解決策**：
- DocumentFragmentを使用してバッチ処理
- テンプレート文字列でHTML生成後、一括挿入

### 3. 計算結果のキャッシュ（削減見込み: -7ループ）
**現在の問題**：
- 同じ計算を複数回実行

**解決策**：
- WeakMapベースのキャッシュシステム
- メモ化パターンの適用

## ProgressTable.ts 最適化戦略

### 1. フィールド処理の統合（削減見込み: -20ループ）
**現在の問題**：
```typescript
this.visibleFields.forEach(field => {
  // 複数箇所で同じループ
});
```

**解決策**：
- フィールド処理を単一のデータ構造生成に統合
- 事前計算された構造を再利用

### 2. イベントハンドラの委譲（削減見込み: -8ループ）
**現在の問題**：
- 各セルにイベントリスナーを個別に追加

**解決策**：
- イベント委譲パターンで親要素に単一のリスナー

### 3. Virtual DOM的アプローチ（削減見込み: -5ループ）
**現在の問題**：
- 全体再描画時のDOM操作

**解決策**：
- 差分更新のみ実行
- 変更検知の最適化

## 実装手順

1. **Step 1**: StaffView.tsのデータ集計統合（30分）
2. **Step 2**: ProgressTable.tsのフィールド処理統合（30分）
3. **Step 3**: キャッシュシステムの実装（20分）
4. **Step 4**: DOM操作の最適化（20分）
5. **検証**: パフォーマンス測定とテスト（20分）

## 期待される成果

### パフォーマンス向上
- 初期レンダリング: 50%高速化
- データ更新: 70%高速化
- メモリ使用量: 30%削減

### コード品質
- 可読性の向上
- 保守性の改善
- テスタビリティの向上

## リスクと対策

### リスク
- 既存機能の破損
- ブラウザ互換性の問題

### 対策
- 段階的な実装
- 各ステップでのテスト実施
- ロールバック可能な構造